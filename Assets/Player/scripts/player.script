--[[
  
]]
local debugger = require('debugger.debugger')
debugger.start()

require 'Assets.Modules.general'
local camera = require 'Assets.libs.orthographic.camera'

local nutsprite = '#sprite'

local idle_up = hash 'idle-up'
local walk_up = hash 'walk-up'
local roll_up = hash 'roll-up'
local stop_roll_up = hash 'stop-roll-up'

local idle_right = hash 'idle-right'
local walk_right = hash 'walk-right'
local roll_right = hash 'roll-right'
local stop_roll_right = hash 'stop-roll-right'

local idle_left = hash 'idle-left'
local walk_left = hash 'walk-left'
local roll_left = hash 'roll-left'
local stop_roll_left = hash 'stop-roll-left'

local idle_down = hash 'idle-down'
local walk_down = hash 'walk-down'
local roll_down = hash 'roll-down'
local stop_roll_down = hash 'stop-roll-down'

local default_anim = idle_down

local dir_right = 'r'
local dir_down = 'd'
local dir_up = 'u'
local dir_left = 'l'

local function set_x_pos(x)
  go.set_position(vmath.vector3(x, go.get_position().y, go.get_position().z))
end

local function set_y_pos(x)
  go.set_position(vmath.vector3(go.get_position().x, y, go.get_position().z))
end

local function set_xy_pos(x, y)
  go.set_position(vmath.vector3(x, y, go.get_position().z))
end

function acquire_input ()
  msg.post('.', hash('acquire_input_focus'))
end

function quick_animation(self, sprite, anim)
  if anim ~= self.current_anim then
    msg.post(sprite, "play_animation", { id = anim })
    self.current_anim = anim
  end
end

go.property('regular_speed', 50)
go.property('rolling_speed', 100)

go.property('regular_friction', 0.07)




function init(self)
  self.correction = vmath.vector3()
  self.dir = vmath.vector3()
  self.last_dir_vector = vmath.vector3()

  self.can_move = true
  self.last_dir = nil

  self.current_anim = nil

  self.can_roll = true

  self.dx = 0
  self.dy = 0

  self.on_action_area = false
  self.action_area_group = nil
  self.on_action_fun = function () end

  self.rolling = 'roll'
  self.walking = 'walk'
  self.stoped_rolling = 'sroll'
  self.state = self.walking

  self.speed = self.regular_speed
  self.friction = self.regular_friction
  
  acquire_input()
end

function on_message(self, message_id, message)
  local msg_fun_t = {
    [hash "contact_point_response"] = function ()
      local group = message.other_group

      if
        group == collisions.overworld
      then
        if message.distance > 0 then
          local proj = vmath.project(self.correction, message.normal * message.distance)
          if proj < 1 then
            local comp = (message.distance - message.distance * proj) * message.normal
            go.set_position(go.get_position() + comp)
            self.correction = self.correction + comp
          end
        end
      end
    end,
  
    [hash "animation_done"] = function ()
      local function stopped_roll()
        self.can_move = true
        self.can_roll = true
        self.state = self.walking
        self.last_dir_vector = vmath.vector3()
      end
    
      local function roll()
        self.state = self.stoped_rolling
      end
    
      local jumpt = {
        [stop_roll_up] = stopped_roll,
        [stop_roll_right] = stopped_roll,
        [stop_roll_down] = stopped_roll,
        [stop_roll_left] = stopped_roll,
    
        [roll_up] = roll,
        [roll_right] = roll,
        [roll_left] = roll,
        [roll_down] = roll,
      } 
      
      if jumpt[message.id] then
        jumpt[message.id]()
      end
    end,

    [hash "trigger_response"] = function ()
      if message.other_group == trigger.sign then
        print'asdf'
      end
      local trigger_fun_t = {
        [trigger.sign] = function ()
          
        end
      }

      if message.enter then
        self.on_action_area = true
        self.action_area_group = message.other_group

        self.on_action_fun = trigger_fun_t[message.other_group]
      else
        self.on_action_area = false
        self.action_area_group = nil
      end
    end,

    [hash "collision_response"] = function ()
    end,
  }

  if msg_fun_t[message_id] then
    msg_fun_t[message_id]()
  else
    print('no function for the MESSAGE: ', message_id)
  end
end

function update(self, dt)
  local function update_animation(self)
    local anim = default_anim

    local updateAnimation_fun_t = {
      [self.walking] = function ()

        if self.dir.x > 0 then
          anim = walk_right

        elseif self.dir.x < 0 then
          anim = walk_left

        elseif self.dir.y > 0 then
          anim = walk_up

        elseif self.dir.y < 0 then
          anim = walk_down

        else
          if self.last_dir == dir_down then
            anim = idle_down

          elseif self.last_dir == dir_left then
            anim = idle_left
            
          elseif self.last_dir == dir_right then
            anim = idle_right

          elseif self.last_dir == dir_up then
            anim = idle_up
          end
        end
      end,

      [self.rolling] = function ()
        if self.last_dir_vector.x > 0 then
          anim = roll_right

        elseif self.last_dir_vector.x < 0 then
          anim = roll_left

        elseif self.last_dir_vector.y > 0 then
          anim = roll_up

        elseif self.last_dir_vector.y < 0 then
          anim = roll_down

        end

      end,

      [self.stoped_rolling] = function ()
        if self.last_dir_vector.x > 0 then
          anim = stop_roll_right

        elseif self.last_dir_vector.x < 0 then
          anim = stop_roll_left

        elseif self.last_dir_vector.y > 0 then
          anim = stop_roll_up

        elseif self.last_dir_vector.y < 0 then
          anim = stop_roll_down

        end
      end
    }

    if updateAnimation_fun_t[self.state] then
      updateAnimation_fun_t[self.state]()
    else
      print('no move function for: ', self.state)
    end

    quick_animation(self, nutsprite, anim)
  end

  local function update_move(self, dt)
    local x, y, dir

    if self.state == self.rolling then
      self.speed = self.rolling_speed
      dir = self.last_dir_vector

    elseif self.state == self.stoped_rolling then
      self.speed = self.rolling_speed * 25/100
      dir = self.last_dir_vector

    else
      self.speed = self.regular_speed
      dir = self.dir

    end

    if dir ~= vmath.vector3() then
      dir = vmath.normalize(dir)
    end

    x = go.get_position().x + self.dx * self.speed * dt
    y = go.get_position().y + self.dy * self.speed * dt
    set_xy_pos(x, y)

    self.dx = self.dx * (1 - self.friction)
    self.dy = self.dy * (1 - self.friction)

    local kx = dir.x
    local ky = dir.y

    self.dx = self.dx + kx
    self.dy = self.dy + ky

  end

  local function reset_vars(self)
    self.dir = vmath.vector3()
    self.correction = vmath.vector3()
  end


  update_move(self, dt)
  update_animation(self)
  reset_vars(self)
end

function on_input(self, action_id, action)
  local function input_move(self, action_id, action)
    if self.can_move then
      if action_id == key.down then
        self.state = self.walking

        if action.released then
          self.moving = false  
          self.last_dir_vector.y = 0
        else
          self.last_dir_vector.y = -1
          self.dir.y = -1
          self.last_dir = dir_down
          self.moving = true
        end

      elseif action_id == key.up then
        self.state = self.walking
        if action.released then
          self.moving = false
          self.last_dir_vector.y = 0
        else
          self.last_dir_vector.y = 1
          self.dir.y = 1
          self.last_dir = dir_up
          self.moving = true
        end

      elseif action_id == key.left then
        self.state = self.walking
        if action.released then
          self.moving = false 
          self.last_dir_vector.x = 0
        else
          self.dir.x = -1
          self.last_dir_vector.x = -1
          self.last_dir = dir_left
          self.moving = true
        end

      elseif action_id == key.right then
        self.state = self.walking
        if action.released then
          self.moving = false 
          self.last_dir_vector.x = 0
        else
          self.dir.x = 1
          self.last_dir_vector.x = 1
          self.last_dir = dir_right
          self.moving = true
        end
      end
    end
  end

  local function input_action(self, action_id, action)
    if self.on_action_area then
      if action_id == key.action  then
        if action.pressed then
          self.on_action_fun()
        end
      end
      
      return
    end

    if
      action_id == key.action and
      self.can_roll and self.moving 
    then
      if action.pressed then
        self.can_roll = false
        self.can_move = false
        self.state = self.rolling
      end
    end
  end

  input_move(self, action_id, action)
  input_action(self, action_id, action)
end