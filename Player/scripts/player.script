--[[
TODO:
  - add a bit of extra speed when getting out of a roll
]]

require 'general.general'

local nutsprite = '#sprite'

local idle_down = hash 'idle-down'
local walk_down = hash 'walk-down'
local roll_down = hash 'roll-down'

local idle_left = hash 'idle-left'
local walk_left = hash 'walk-left'
local roll_left = hash 'roll-left'

local idle_right = hash 'idle-right'
local walk_right = hash 'walk-right'
local roll_right = hash 'roll-right'

local idle_up = hash 'idle-up'
local walk_up = hash 'walk-up'
local roll_up = hash 'roll-up'


local dir_right = 'r'
local dir_down = 'd'
local dir_up = 'u'
local dir_left = 'l'

go.property('speed', 50)
go.property('rolling_speed', 300)

function acquire_input ()
  msg.post('.', hash('acquire_input_focus'))
end

function quick_animation(self, sprite, anim)
  if anim ~= self.current_anim then
    msg.post(sprite, "play_animation", { id = anim })
    self.current_anim = anim
  end
end

function init(self)
  self.correction = vmath.vector3()
  acquire_input()
  self.dir = vmath.vector3()
  self.actual_speed = self.speed
  self.rolling = false
  self.can_move = true
  self.last_dir = nil
  self.current_anim = nil
  self.start_decresing_rolling_speed = false
  self.rolling_decrease = 10
  self.can_roll = false
  self.can_crouch = true
end

function slide_on_collision(self, message)
  local group = message.other_group
  if
    group == collisions.map_terrain or
    group == collisions.map_terrains or
    group == collisions.stone
  then
    if message.distance > 0 then
      local proj = vmath.project(self.correction, message.normal * message.distance)
      if proj < 1 then
        local comp = (message.distance - message.distance * proj) * message.normal
        go.set_position(go.get_position() + comp)
        self.correction = self.correction + comp
      end
    end
  end
end

local function animation_done(self, message)
  local function end_rolling()
    self.start_decresing_rolling_speed = false
    self.rolling = false
    self.actual_speed = self.speed
    self.can_roll = false
    update_animation(self)
  end

  local jumpt = {
    [roll_right] = end_rolling,
    [roll_left] = end_rolling,
    [roll_up] = end_rolling,
    [roll_down] = end_rolling,
  } 
  
  local id = message.id
  if jumpt[id] then
    jumpt[id]()
  end
end

function on_message(self, message_id, message)
  -- Handle collision
  if message_id == hash "contact_point_response" then
    slide_on_collision(self, message)

  elseif message_id == hash 'animation_done' then
    animation_done(self, message)
  end  
end

function update_animation(self)
  local anim = idle_down

  if self.dir.x > 0 then
    anim = walk_right
    if self.rolling then
      anim = roll_right
    end

  elseif self.dir.x < 0 then
    anim = walk_left
    if self.rolling then
      anim = roll_left
    end

  elseif self.dir.y > 0 then
    anim = walk_up
    if self.rolling then
      anim = roll_up
    end

  elseif self.dir.y < 0 then
    anim = walk_down
    if self.rolling then
      anim = roll_down
    end

  else
    if self.last_dir == dir_down then
      anim = idle_down

    elseif self.last_dir == dir_left then
      anim = idle_left
      
    elseif self.last_dir == dir_right then
      anim = idle_right

    elseif self.last_dir == dir_up then
      anim = idle_up
    end
  end



  quick_animation(self, nutsprite, anim)
end

function update_move(self, dt)
  if vmath.length_sqr(self.dir) > 1 then
    self.dir = vmath.normalize(self.dir)
  end

  if self.rolling then
    if not self.start_decresing_rolling_speed then
      self.actual_speed = self.rolling_speed
      self.start_decresing_rolling_speed = true
    end

    if self.last_dir == dir_down then
      self.dir.y = -1

    elseif self.last_dir == dir_left then
      self.dir.x = -1
      
    elseif self.last_dir == dir_right then
      self.dir.x = 1

    elseif self.last_dir == dir_up then
      self.dir.y = 1
    end
  end
  
  local p = go.get_position()
  go.set_position(p + self.dir * self.actual_speed * dt)
end

function reset_vars(self)
  self.dir = vmath.vector3()
  self.correction = vmath.vector3()
  if self.rolling then
    self.can_move = false
  else
    self.can_move = true
  end
end

function update(self, dt)
  update_move(self, dt)
  update_animation(self)
  reset_vars(self)
end

local function input_move(self, action_id, action)
  if self.can_move then
    if action_id == key.down then
      self.dir.y = -1
      self.last_dir = dir_down
      self.can_roll = true

      if action.released then
        self.can_roll = false
      end

    elseif action_id == key.up then
      self.dir.y = 1
      self.last_dir = dir_up
      self.can_roll = true

      if action.released then
        self.can_roll = false
      end

    elseif action_id == key.left then
      self.dir.x = -1
      self.last_dir = dir_left
      self.can_roll = true

      if action.released then
        self.can_roll = false
      end

    elseif action_id == key.right then
      self.dir.x = 1
      self.last_dir = dir_right
      self.can_roll = true

      if action.released then
        self.can_roll = false
      end
    end
  end

  if action_id == key.action and action.pressed and self.can_roll then
    self.rolling = true
  end

end

function on_input(self, action_id, action)
  input_move(self, action_id, action)
end