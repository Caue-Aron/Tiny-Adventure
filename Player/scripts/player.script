--[[
  
]]
local debugger = require('debugger.debugger')
debugger.start()


require 'general.general'
local camera = require 'orthographic.camera'

local nutsprite = '#sprite'

local idle_down = hash 'idle-down'
local walk_down = hash 'walk-down'
local roll_down = hash 'roll-down'

local idle_left = hash 'idle-left'
local walk_left = hash 'walk-left'
local roll_left = hash 'roll-left'

local idle_right = hash 'idle-right'
local walk_right = hash 'walk-right'
local roll_right = hash 'roll-right'
local crouch_right = hash 'crouch-right'

local idle_up = hash 'idle-up'
local walk_up = hash 'walk-up'
local roll_up = hash 'roll-up'

local default_anim = idle_down

local dir_right = 'r'
local dir_down = 'd'
local dir_up = 'u'
local dir_left = 'l'

local function set_x_pos(x)
  
end

local function set_x_pos(x)
  
end

local function set_xy_pos(x, y)
  
end

function acquire_input ()
  msg.post('.', hash('acquire_input_focus'))
end

function quick_animation(self, sprite, anim)
  if anim ~= self.current_anim then
    msg.post(sprite, "play_animation", { id = anim })
    self.current_anim = anim
  end
end

go.property('walking_speed', 50)
go.property('crouch_max_speed', 225)
go.property('crouch_accel', 7)

go.property('friction', 0.5)

function init(self)
  self.correction = vmath.vector3()
  self.dir = vmath.vector3()
  self.last_dir_vector = self.dir
  self.speed = vmath.vector3()
  self.can_move = true
  self.last_dir = nil
  self.current_anim = nil
  self.can_crouch = true
  self.crouching = false
  self.started_crouch = false
  self.crouching_mod_vector = vmath.vector3()
  self.slide_effect = 1
  self.dx = 0
  self.dy = 0
  
  acquire_input()
end

local function slide_on_collision(self, message)
  local group = message.other_group
  if
    group == collisions.map_terrain or
    group == collisions.map_terrains or
    group == collisions.stone
  then
    if message.distance > 0 then
      local proj = vmath.project(self.correction, message.normal * message.distance)
      if proj < 1 then
        local comp = (message.distance - message.distance * proj) * message.normal
        go.set_position(go.get_position() + comp)
        self.correction = self.correction + comp
      end
    end
  end
end

local function animation_done(self, message)
  local function end_rolling()
    self.start_decresing_rolling_speed = false
    self.rolling = false
    self.actual_speed = self.speed
    self.can_roll = false
    update_animation(self)
  end

  local jumpt = {
    [roll_right] = end_rolling,
    [roll_left] = end_rolling,
    [roll_up] = end_rolling,
    [roll_down] = end_rolling,
  } 
  
  if jumpt[message.id] then jumpt[message.id]() end
end

function on_message(self, message_id, message)
  if message_id == hash "contact_point_response" then
    slide_on_collision(self, message)

  elseif message_id == hash 'animation_done' then
    animation_done(self, message)
  end  
end

local function update_animation(self)
  local anim = default_anim

  if self.dir.x > 0 then
    anim = walk_right

  elseif self.dir.x < 0 then
    anim = walk_left

  elseif self.dir.y > 0 then
    anim = walk_up

  elseif self.dir.y < 0 then
    anim = walk_down

  else
    if self.last_dir == dir_down then
      anim = idle_down

    elseif self.last_dir == dir_left then
      anim = idle_left
      
    elseif self.last_dir == dir_right then
      anim = idle_right

    elseif self.last_dir == dir_up then
      anim = idle_up
    end
  end

  quick_animation(self, nutsprite, anim)
end

local function update_move(self, dt)
  local z = go.get_position().z
  go.set_position(vmath.vector3(
    go.get_position().x + self.dx * self.walking_speed * dt,
    go.get_position().y + self.dy * self.walking_speed * dt,
    z))

  self.dx = self.dx * (1 - self.friction)
  self.dy = self.dy * (1 - self.friction)

  local kx = self.dir.x
  local ky = self.dir.y

  self.dx = self.dx + kx
  self.dy = self.dy + ky

  go.set_position(vmath.vector3(go.get_position().x, go.get_position().y, z))
end

local function reset_vars(self)
  self.dir = vmath.vector3()
  self.correction = vmath.vector3()
end

function update(self, dt)
  update_move(self, dt)
  update_animation(self)
  reset_vars(self)
end

local function input_move(self, action_id, action)
  if self.can_move then
    if action_id == key.down then
      if action.released then
        self.moving = false
      
      else
        self.dir.y = -1
        self.last_dir = dir_down
        self.moving = true
      end

    elseif action_id == key.up then
      if action.released then
        self.moving = false
      else
        self.dir.y = 1
        self.last_dir = dir_up
        self.moving = true
      end

    elseif action_id == key.left then
      if action.released then
        self.moving = false 
      else
        self.dir.x = -1
        self.last_dir = dir_left
        self.moving = true
      end

    elseif action_id == key.right then
      if action.released then
        self.moving = false 
      else
        self.dir.x = 1
        self.last_dir = dir_right
        self.moving = true
      end

    end
    
    if self.moving then
      self.last_dir_vector = self.dir
    end
  end



  if action_id == key.action and self.can_crouch then
    if action.pressed then
      self.started_crouch = true
      self.crouching = true
      self.can_crouch = false

    elseif action.released then
      self.crouching = false
      self.can_crouch = true
    end
  end

end

function on_input(self, action_id, action)
  input_move(self, action_id, action)
end